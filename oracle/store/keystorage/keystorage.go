package keystorage

import (
	"encoding/json"
	"fmt"
	"github.com/sirupsen/logrus"
	"io/ioutil"
	"oracle/models"
	"oracle/utils/walletworker"
	"os"
)

type Keystorage struct {
	log      *logrus.Logger
	File     *os.File
	KeyStore *models.KeyStorageModel
}

// exists returns whether the given file or directory exists
func existsFile(path string) (bool, error) {
	_, err := os.Stat(path)
	if err == nil {
		return true, nil
	}
	if os.IsNotExist(err) {
		return false, nil
	}
	return false, err
}

func NewKeyStorage(log *logrus.Logger, filePath string) (*Keystorage, error) {
	var err error
	var keystoreFile *os.File
	var keyStore = models.KeyStorageModel{}

	if _, err = os.Stat(filePath); err == nil {
		log.WithFields(logrus.Fields{
			"package":  "keystorage",
			"function": "NewKeyStorage",
			"action":   "reading file",
		}).Info()
		keystoreFile, err = os.OpenFile(filePath, os.O_RDWR|os.O_CREATE, 0755)
		if err != nil {
			log.WithFields(logrus.Fields{
				"package":  "keystorage",
				"function": "NewKeyStorage",
				"action":   "reading file",
				"result":   err.Error(),
			}).Error()
			return nil, err
		}

		data, err := ioutil.ReadAll(keystoreFile)
		if err != nil {
			log.WithFields(logrus.Fields{
				"package":  "keystorage",
				"function": "NewKeyStorage",
				"action":   "init KeyStore object",
				"result":   err.Error(),
			}).Error()
			return nil, err
		}

		err = json.Unmarshal(data, &keyStore)
		if err != nil {
			log.WithFields(logrus.Fields{
				"package":  "keystorage",
				"function": "NewKeyStorage",
				"action":   "unmarshal json from file",
				"result":   err.Error(),
			}).Error()
		}
	} else if os.IsNotExist(err) {
		keystoreFile, err = os.Create(filePath)
		_, err := keystoreFile.Write([]byte(`{"keys":[]}`))
		keyStore.Key = &[]models.KeyStorageKeyModel{}
		if err != nil {
			log.WithFields(logrus.Fields{
				"package":  "keystorage",
				"function": "NewKeyStorage",
				"action":   "creating file",
				"result":   err.Error(),
			}).Error()
			return nil, err
		}

	}

	return &Keystorage{
		log:      log,
		File:     keystoreFile,
		KeyStore: &keyStore,
	}, err
}

func (d *Keystorage) GetFirst() models.KeyStorageKeyModel {
	return (*d.KeyStore.GetKey())[0]
}

func (d *Keystorage) AddGenerated(username string) error {
	_, keyGeneratedString, err := walletworker.GeneratePrivate()
	if err != nil {
		return err
	}
	var newKey = append(*d.KeyStore.Key, models.KeyStorageKeyModel{
		Account: func() string {
			if username == "" {
				return "autogenerated"
			}
			return username
		}(),
		CipherPrivate: keyGeneratedString,
	})
	d.KeyStore.Key = &newKey
	err = d.save()
	return err
}

func (d Keystorage) GetByAccount(account string) (models.KeyStorageKeyModel, error) {
	var keys = d.KeyStore.GetKey()
	for _, key := range *keys {
		if key.Account == account {
			return key, nil
		}
	}
	return models.KeyStorageKeyModel{}, fmt.Errorf("Can't find user, sorry.")
}

func (d Keystorage) Exists() bool {
	if len(*(d.KeyStore.GetKey())) > 0 {
		return true
	}

	return false
}

func (d Keystorage) save() error {
	jsonByte, err := json.Marshal(d.KeyStore)
	if err != nil {
		return err
	}
	_, err = d.File.WriteAt(jsonByte, 0)
	return err
}
